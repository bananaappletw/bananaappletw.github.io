"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1691],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=c(n),u=r,d=h["".concat(s,".").concat(u)]||h[u]||m[u]||o;return n?a.createElement(d,i(i({ref:t},p),{},{components:n})):a.createElement(d,i({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},38459:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"symbolic exection introduction",tags:[],categories:[],date:new Date("2016-02-23T09:19:00.000Z")},i="Symbolic execution",l={permalink:"/archives/symbolic-exection-introduction",editUrl:"https://github.com/banananappletw/blog/edit/master/blog/archives/archives/symbolic-exection-introduction.md",source:"@site/archives/symbolic-exection-introduction.md",title:"symbolic exection introduction",description:"*",date:"2016-02-23T09:19:00.000Z",formattedDate:"February 23, 2016",tags:[],readingTime:3.835,hasTruncateMarker:!1,authors:[],frontMatter:{title:"symbolic exection introduction",tags:[],categories:[],date:"2016-02-23T09:19:00.000Z"},prevItem:{title:"useful tools",permalink:"/archives/useful-tools"}},s={authorsImageUrls:[]},c=[{value:"Path Explosion",id:"path-explosion",level:2},{value:"Program-Dependent Efficacy",id:"program-dependent-efficacy",level:2},{value:"Environment Interactions",id:"environment-interactions",level:2}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("hr",null),(0,r.kt)("h1",{id:"defenition"},"Defenition"),(0,r.kt)("p",null,"Symbolic execution (also symbolic evaluation) is a means of analyzing a program to determine what inputs cause each part of a program to execute."),(0,r.kt)("p",null,"An interpreter follows the program, assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would, a case of abstract interpretation."),(0,r.kt)("p",null,"It thus arrives at expressions in terms of those symbols for expressions and variables in the program, and constraints in terms of those symbols for the possible outcomes of each conditional branch."),(0,r.kt)("h1",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'int f() {\n  ...\n  y = read();\n  z = y * 2;\n  if (z == 12) {\n    fail();\n  } else {\n    printf("OK");\n  }\n}\n')),(0,r.kt)("p",null,'During "concrete" execution, the program would read a concrete input value (e.g., 5) and assign it to y.'),(0,r.kt)("p",null,"During symbolic execution, the program reads a symbolic value (e.g., \u03bb) and assigns it to y."),(0,r.kt)("p",null,"The program would then proceed with the multiplication and assign \u03bb ",(0,r.kt)("em",{parentName:"p"}," 2 to z. When reaching the if statement, it would evaluate \u03bb ")," 2 == 12."),(0,r.kt)("p",null,'At this point of the program, \u03bb could take any value, and symbolic execution can therefore proceed along both branches, by "forking" two paths.'),(0,r.kt)("p",null,"Each path get assigned a copy of the program state at the branch instruction as well as a path constraint."),(0,r.kt)("p",null,"When paths terminate (e.g., as a result of executing fail() or simply exiting), symbolic execution computes a concrete value for \u03bb by solving the accumulated path constraints on each path."),(0,r.kt)("h1",{id:"limitations"},"Limitations"),(0,r.kt)("h2",{id:"path-explosion"},"Path Explosion"),(0,r.kt)("p",null,"Symbolically executing all feasible program paths does not scale to large programs."),(0,r.kt)("h2",{id:"program-dependent-efficacy"},"Program-Dependent Efficacy"),(0,r.kt)("p",null,"Symbolic execution is used to reason about a program path-by-path which is an advantage over reasoning about a program input-by-input as other testing paradigms use (e.g. Dynamic program analysis)."),(0,r.kt)("p",null,"However, if few inputs take the same path through the program, there is little savings over testing each of the inputs separately."),(0,r.kt)("h2",{id:"environment-interactions"},"Environment Interactions"),(0,r.kt)("p",null,"Programs interact with their environment by performing system calls, receiving signals, etc.\nConsistency problems may arise when execution reaches components that are not under control of the symbolic execution tool (e.g., kernel or libraries)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'int main()\n {\n   FILE *fp = fopen("doc.txt");\n   ...\n   if (condition) {\n     fputs("some data", fp);\n   } else {\n     fputs("some other data", fp);\n   }\n   ...\n   data = fgets(..., fp);\n }\n')),(0,r.kt)("p",null,'This program opens a file and, based on some condition, writes different kind of data to the file. It then later reads back the written data. In theory, symbolic execution would fork two paths at line 5 and each path from there on would have its own copy of the file. The statement at line 11 would therefore return data that is consistent with the value of "condition" at line 5. In practice, file operations are implemented as system calls in the kernel, and are outside the control of the symbolic execution tool. The main approaches to address this challenge are:'),(0,r.kt)("p",null,'Executing calls to the environment directly. The advantage of this approach is that it is simple to implement. The disadvantage is that the side effects of such calls will clobber all states managed by the symbolic execution engine. In the example above, the instruction at line 11 would return "some datasome other data" or "some other datasomedata" depending on the sequential ordering of the states.'),(0,r.kt)("p",null,"Modeling the environment. In this case, the engine instruments the system calls with a model that simulates their effects and that keeps all the side effects in per-state storage. The advantage is that one would get correct results when symbolically executing programs that interact with the environment. The disadvantage is that one needs to implement and maintain many potentially complex models of system calls. Tools such as KLEE","[","5","]"," and Cloud9 take this approach by implementing models for file system operations, sockets, IPC, etc."),(0,r.kt)("p",null,"Forking the entire system state. Symbolic execution tools based on virtual machines solve the environment problem by forking the entire VM state. For example, in S2E","[","6","]"," each state is an independent VM snapshot that can be executed separately. This approach alleviates the need for writing and maintaining complex models and allows virtually any program binary to be executed symbolically. However, it has higher memory usage overheads (VM snapshots may be large)."),(0,r.kt)("h1",{id:"tools"},"Tools"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Tool"),(0,r.kt)("th",{parentName:"tr",align:null},"It can analyze Arch/Lang"),(0,r.kt)("th",{parentName:"tr",align:null},"url"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"KLEE"),(0,r.kt)("td",{parentName:"tr",align:null},"LLVM"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"http://klee.github.io/"},"http://klee.github.io/"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"S2E"),(0,r.kt)("td",{parentName:"tr",align:null},"x86, x86-64, ARM / User and kernel-mode binaries"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"http://s2e.epfl.ch"},"http://s2e.epfl.ch"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Triton"),(0,r.kt)("td",{parentName:"tr",align:null},"x86 and x86-64"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"http://triton.quarkslab.com"},"http://triton.quarkslab.com"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"angr"),(0,r.kt)("td",{parentName:"tr",align:null},"libVEX based"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"http://angr.io/"},"http://angr.io/"))))),(0,r.kt)("h1",{id:"reference"},"Reference"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Symbolic_execution"},"https://en.wikipedia.org/wiki/Symbolic_execution")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://www.tutorialspoint.com/software_testing_dictionary/symbolic_execution.htm"},"http://www.tutorialspoint.com/software_testing_dictionary/symbolic_execution.htm"))))}m.isMDXComponent=!0}}]);